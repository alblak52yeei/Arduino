# Независимое управление светодиодами с использованием таймера и прерываний

## Цель проекта

Создание программы для микроконтроллера AVR (на базе ATmega328P), которая управляет пятью светодиодами, подключенными к одному порту. Каждый светодиод мигает с собственной независимой частотой. Решение реализовано без применения блокирующих функций (`delay()`) и стандартных функций Arduino (`pinMode()`, `digitalWrite()`), используя прямое управление регистрами и обработку прерываний аппаратного таймера.

## Принцип работы

Основная идея решения заключается в использовании аппаратного таймера микроконтроллера для генерации точных временных интервалов. Вместо остановки выполнения основной программы, таймер работает в фоновом режиме и по истечении заданного интервала генерирует прерывание. Функция обработки прерывания (ISR) выполняется автоматически, не блокируя основной цикл программы `loop()`. Вся логика управления состоянием светодиодов реализована внутри этой функции.

### Режим CTC (Clear Timer on Compare Match)

Для данной задачи выбран 16-битный `Timer1`, так как он обеспечивает большую точность и более широкий диапазон временных интервалов по сравнению с 8-битными таймерами.

Таймер настроен на работу в режиме **CTC (Сброс по совпадению)**. В этом режиме счетчик таймера (`TCNT1`) постоянно увеличивается. Когда его значение достигает величины, записанной в регистр сравнения (`OCR1A`), происходят два события:

1.  Генерируется прерывание `TIMER1_COMPA_vect`.
2.  Счетчик `TCNT1` автоматически сбрасывается в ноль и начинает считать заново.

Такой подход позволяет создавать периодические прерывания с высокой точностью.

### Расчет параметров таймера

Точность работы системы зависит от правильной настройки предделителя таймера и значения в регистре сравнения `OCR1A`.

*   **Тактовая частота микроконтроллера:** 16 МГц.
*   **Выбранный предделитель:** 64. Это означает, что счетчик таймера будет инкрементироваться не на каждой тактовой частоте, а в 64 раза медленнее.
*   **Частота работы таймера:** 16 000 000 Гц / 64 = 250 000 Гц (или 250 кГц).
*   **Период одного тика таймера:** 1 / 250 000 с.

Чтобы создать базовый временной интервал, на основе которого будут работать все светодиоды (например, 10 мс или 100 Гц), необходимо рассчитать значение для `OCR1A`:

```
Значение OCR1A = (Частота таймера / Желаемая частота прерываний) - 1
Значение OCR1A = (250 000 / 100) - 1 = 2500 - 1 = 2499
```

Таким образом, при записи `2499` в `OCR1A`, прерывание будет генерироваться ровно 100 раз в секунду, то есть каждые 10 миллисекунд. Этот интервал является минимальной единицей времени ("тиком") для программы.

### Алгоритм в обработчике прерываний

Вся логика переключения светодиодов находится внутри функции `ISR(TIMER1_COMPA_vect)`. Эта функция вызывается автоматически каждые 10 мс.

*   **Массив периодов (`blink_periods`)**: Этот массив хранит, через сколько "тиков" (10-миллисекундных интервалов) должен переключаться каждый светодиод. Например, значение `3` для третьего светодиода означает, что он будет менять свое состояние каждые `3 * 10 = 30 мс`.
*   **Массив счетчиков (`period_counters`)**: Для каждого светодиода заведен отдельный счетчик. Этот счетчик инкрементируется при каждом вызове прерывания.
*   **Логика сравнения**: Внутри ISR для каждого светодиода проверяется условие: `if (period_counters[i] >= blink_periods[i])`.
*   **Переключение состояния**: Если условие истинно, значит, настало время переключить светодиод. Для этого используется побитовая операция **XOR (`^`)** с регистром `PORTB`. Выражение `PORTB = PORTB ^ (1 << i);` инвертирует i-й бит порта B, не затрагивая остальные. Если бит был 1, он станет 0, и наоборот. Это эффективный способ переключения состояния пина.
*   **Сброс счетчика**: После переключения состояния светодиода его персональный счетчик (`period_counters[i]`) сбрасывается в 0, и цикл отсчета для него начинается заново.

## Схема подключения

*   Светодиоды подключены к пинам порта B: `PB0`, `PB1`, `PB2`, `PB3`, `PB4` (на плате Arduino Uno это цифровые пины 8, 9, 10, 11, 12).
*   Настройка пинов на выход осуществляется через регистр направления данных `DDRB` путем установки соответствующих битов в 1.
    ```c
    DDRB = DDRB | ((1 << DDB0) | ... | (1 << DDB4));
    ```
*   Начальное состояние светодиодов (включены) задается записью в регистр данных `PORTB`.
    ```c
    PORTB = PORTB | ((1 << PORTB0) | ... | (1 << PORTB4));
    ```