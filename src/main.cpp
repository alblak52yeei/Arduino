#include <Arduino.h> // Подключаем основную библиотеку Arduino

#define LED_COUNT 5 // Определяем количество светодиодов, которыми мы управляем

// Массив, задающий периоды мигания для каждого светодиода.
// Период измеряется не в секундах, а в количестве тиков таймера.
// Например, led_periods[0] = 1 означает, что светодиод 0 будет менять свое состояние каждый тик таймера.
// led_periods[1] = 2 означает, что светодиод 1 будет менять состояние каждые 2 тика таймера.
const unsigned int led_periods[LED_COUNT] = {1, 2, 3, 4, 5};

// Массив счетчиков для каждого светодиода. Каждый счетчик будет инкрементироваться при каждом тике таймера.
// Ключевое слово "volatile" обязательно, так как эта переменная изменяется внутри прерывания (ISR)
// и используется в основном цикле (loop). Оно говорит компилятору не оптимизировать доступ к этой переменной,
// так как ее значение может измениться в любой момент "неожиданно" для основного потока кода.
volatile unsigned int led_counters[LED_COUNT] = {0};

// Флаг для синхронизации вывода в Serial порт с прерыванием.
// Прерывание устанавливает его в 'true', а основной цикл 'loop' сбрасывает в 'false'.
// Также используется 'volatile' по той же причине, что и для led_counters.
volatile bool readyToPrint = false;

// --- Функция начальной настройки, выполняется один раз при запуске ---
void setup() {
  // Инициализация последовательного порта для вывода отладочной информации
  Serial.begin(9600);
  Serial.println("--- Система инициализирована ---");

  // Настройка пинов PB0-PB4 (на Arduino Uno это цифровые пины 8, 9, 10, 11, 12) как выходы.
  // Мы делаем это через прямую запись в регистр DDRB (Data Direction Register for Port B),
  // что является более быстрым и низкоуровневым способом по сравнению с pinMode().
  // (1 << DDB0) создает битовую маску ...00001, (1 << DDB1) - ...00010, и т.д.
  // Операция '|=' (побитовое ИЛИ с присваиванием) устанавливает нужные биты в 1, не затрагивая остальные.
  DDRB |= (1 << DDB0) | (1 << DDB1) | (1 << DDB2) | (1 << DDB3) | (1 << DDB4);
  Serial.print("Регистр DDRB установлен в: 0b");
  Serial.println(DDRB, BIN);

  // --- Настройка Таймера1 для генерации прерываний с частотой 100 Гц ---
  
  // Сбрасываем регистры управления таймером для чистой настройки
  TCCR1A = 0;
  TCCR1B = 0;
  
  // Устанавливаем режим работы таймера: WGM12 = 1 означает режим CTC (Clear Timer on Compare Match).
  // В этом режиме таймер считает от 0 до значения в регистре OCR1A, после чего сбрасывается в 0 и генерирует прерывание.
  TCCR1B |= (1 << WGM12);
  
  // Устанавливаем предделитель (prescaler) на 64.
  // Это значит, что таймер будет тикать с частотой F_CPU / 64.
  // Для Arduino Uno (16 МГц): 16,000,000 / 64 = 250,000 тиков в секунду.
  TCCR1B |= (1 << CS11) | (1 << CS10);
  
  // Устанавливаем значение для сравнения. Прерывание будет срабатывать, когда счетчик TCNT1 достигнет этого значения.
  // Частота прерываний = (Частота таймера) / (OCR1A + 1)
  // 100 Гц = 250,000 / (2499 + 1) = 250,000 / 2500
  OCR1A = 2499;
  
  // Разрешаем прерывание по совпадению с OCR1A (Timer/Counter1 Output Compare A Match Interrupt Enable).
  TIMSK1 |= (1 << OCIE1A);

  Serial.println("Таймер1 настроен на прерывания с частотой 100 Гц.");

  // Глобально разрешаем все прерывания в микроконтроллере. Без этой команды ISR не будет работать.
  sei();
  Serial.println("Глобальные прерывания включены. Запуск...");
  Serial.println("------------------------------------");
}

// --- Обработчик прерывания таймера 1 по совпадению A (TIMER1_COMPA_vect) ---
// Этот код выполняется автоматически 100 раз в секунду, независимо от того, что происходит в loop().
ISR(TIMER1_COMPA_vect) {
  // Проходим по каждому счетчику для каждого светодиода
  for (int i = 0; i < LED_COUNT; i++) {
    led_counters[i]++; // Увеличиваем счетчик на 1

    // Проверяем, не достиг ли счетчик заданного для этого светодиода периода
    if (led_counters[i] >= led_periods[i]) {
      // Это самая интересная часть. Операция XOR (^) с битовой маской (1 << i) 
      // инвертирует состояние одного конкретного бита в регистре PORTB, не затрагивая остальные.
      // Если бит был 0 (светодиод выключен), он станет 1 (включен).
      // Если был 1 (включен), станет 0 (выключен).
      // Это очень эффективный способ переключения светодиода.
      PORTB ^= (1 << i);

      // Сбрасываем счетчик, чтобы начать отсчет заново
      led_counters[i] = 0;
    }
  }

  // Устанавливаем флаг, сообщая основному циклу loop(), что можно обновить информацию на экране.
  // Это хороший способ избежать вызова Serial.print() внутри прерывания, т.к. это медленная операция.
  readyToPrint = true;
}

// --- Основной цикл программы, выполняется бесконечно ---
void loop() {
  // Проверяем флаг, установленный в прерывании.
  if (readyToPrint) {
    readyToPrint = false; // Немедленно сбрасываем флаг, чтобы этот блок выполнился только один раз за прерывание.

    // Используем статический счетчик, чтобы выводить информацию не каждый раз, а реже.
    // 'static' означает, что переменная сохраняет свое значение между вызовами функции loop().
    static int print_counter = 0;
    print_counter++;

    // Вывод будет происходить каждые 50 срабатываний прерывания.
    // Так как прерывание срабатывает 100 раз/сек, вывод будет 100/50 = 2 раза/сек (каждые 500 мс).
    if (print_counter >= 50) {
      print_counter = 0; // Сбрасываем счетчик вывода

      // Выводим текущие значения счетчиков
      Serial.print("Счетчики: [");
      for(int i = 0; i < LED_COUNT; i++) {
        Serial.print(led_counters[i]);
        if (i < LED_COUNT - 1) Serial.print(", ");
      }
      Serial.print("] \t");

      // Выводим текущее состояние порта B в двоичном виде
      Serial.print("Состояние PORTB: 0b");
      // Идем в обратном порядке, чтобы напечатать биты в привычном виде (старший бит слева)
      for (int i = 4; i >= 0; i--) {
        Serial.print(bitRead(PORTB, i));
      }
      Serial.println();
    }
  }
  
  // Здесь может быть другой код. Он будет выполняться, пока МК ждет следующего прерывания.
  // Важно, чтобы этот код не содержал долгих задержек (delay()), чтобы не мешать
  // своевременной обработке флага readyToPrint.
}