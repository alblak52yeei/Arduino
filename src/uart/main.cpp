#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/atomic.h>

// --- Конфигурация пинов ---
// Определяем пин для передачи (TX). На Arduino Uno это цифровой пин 3.
#define UART_TX_PIN PD3 
 // Определяем пин для приема (RX). На Arduino Uno это цифровой пин 2, который также является пином внешнего прерывания INT0.
#define UART_RX_PIN PD2

// --- Конфигурация буферов ---
// Размер буфера для исходящих данных (в байтах)
#define TX_BUFFER_SIZE 64 
// Размер буфера для входящих данных (в байтах)
#define RX_BUFFER_SIZE 64 

// --- Структуры данных ---

// Структура для кольцевого (циклического) буфера.
// Позволяет безопасно читать и писать данные из основного кода и прерываний.
typedef struct {
    // Индекс, куда будет записан следующий байт. Увеличивается при записи.
    volatile uint8_t head; 
    // Индекс, откуда будет прочитан следующий байт. Увеличивается при чтении.
    volatile uint8_t tail;
    // Массив для хранения данных.
    char buffer[RX_BUFFER_SIZE]; 
} RingBuffer;

// Создаем экземпляры буферов для приема и передачи
RingBuffer rx_buffer = {0, 0};
RingBuffer tx_buffer = {0, 0};

// --- Глобальные переменные состояния ---

// Ключевая переменная: сколько тиков таймера приходится на передачу/прием одного бита при заданной скорости.
volatile uint16_t timer_ticks_per_bit;

// Состояния для автомата состояний передатчика (Transmitter State Machine)
enum TxState {
    TX_IDLE,       // Передатчик свободен, ничего не делает
    TX_START_BIT,  // Передача стартового бита (всегда 0)
    TX_DATA_BITS,  // Передача 8 битов данных
    TX_STOP_BIT    // Передача стопового бита (всегда 1)
};
volatile TxState tx_state = TX_IDLE; // Текущее состояние передатчика
volatile uint8_t tx_byte;            // Байт, который передается в данный момент
volatile uint8_t tx_bit_index;       // Номер текущего передаваемого бита (от 0 до 7)

// Состояния для автомата состояний приемника (Receiver State Machine)
enum RxState {
    RX_IDLE,       // Приемник ждет стартовый бит
    RX_DATA_BITS,  // Прием 8 битов данных
    RX_STOP_BIT    // Ожидание стопового бита
};
volatile RxState rx_state = RX_IDLE; // Текущее состояние приемника
volatile uint8_t rx_byte;            // Байт, который собирается из принимаемых битов
volatile uint8_t rx_bit_index;       // Номер текущего принимаемого бита (от 0 до 7)


// --- Функции ---

/**
 * @brief Настраивает UART и таймеры для заданной скорости.
 * @param baud Скорость передачи данных, например, 9600.
 */
void uart_set_baudrate(uint16_t baud) {
    // Выбираем предделитель таймера. 8 - хороший компромисс между точностью и диапазоном скоростей.
    uint32_t prescaler = 8;
    // Рассчитываем длительность одного бита в тиках таймера
    timer_ticks_per_bit = (F_CPU / prescaler) / baud;

    // Настройка пина TX (передача)
    DDRD |= (1 << UART_TX_PIN);  // Установить пин как выход
    PORTD |= (1 << UART_TX_PIN); // Установить высокий уровень (состояние покоя для UART)

    // Настройка пина RX (прием)
    DDRD &= ~(1 << UART_RX_PIN); // Установить пин как вход
    PORTD |= (1 << UART_RX_PIN); // Включить внутренний подтягивающий резистор для стабильности

    // Настройка Таймера1
    TCCR1A = 0;                  // Режим Normal, выходы OC1A/OC1B отключены
    TCCR1B = (1 << CS11);        // Установить предделитель на 8 (CLK/8)

    // Настройка внешнего прерывания INT0 (на пине PD2/RX)
    EICRA |= (1 << ISC01);       // Срабатывание прерывания по спадающему фронту сигнала (начало старт-бита)
    EICRA &= ~(1 << ISC00);
    EIMSK |= (1 << INT0);        // Включить прерывание INT0

    sei(); // Глобально разрешить все прерывания
}

/**
 * @brief Помещает один байт в буфер для последующей отправки.
 * @param b Байт для отправки.
 */
void uart_send(char b) {
    // Вычисляем, куда будет указывать 'head' после добавления нового байта
    uint8_t next_head = (tx_buffer.head + 1) % TX_BUFFER_SIZE;
    
    // Ждем, пока в буфере появится свободное место.
    // Это блокирующая операция: если буфер полон, функция "зависнет" здесь.
    while (next_head == tx_buffer.tail) {
        // Можно добавить код для обработки переполнения или просто ждать
    }
    
    tx_buffer.buffer[tx_buffer.head] = b; // Помещаем байт в буфер
    tx_buffer.head = next_head;           // Сдвигаем "голову" буфера

    // Атомарный блок: этот код не может быть прерван другим прерыванием.
    // Это важно, чтобы безопасно проверить и изменить tx_state.
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        // Если передатчик был в состоянии покоя, его нужно "разбудить"
        if (tx_state == TX_IDLE) {
            tx_state = TX_START_BIT; // Начинаем процесс передачи
            OCR1B = TCNT1 + 10;      // Запускаем таймер на ближайшее будущее, чтобы начать отправку
            TIMSK1 |= (1 << OCIE1B); // Включаем прерывание по совпадению B для передатчика
        }
    }
}

/**
 * @brief Отправляет строку (массив символов, заканчивающийся '\0').
 * @param msg Указатель на строку для отправки.
 */
void uart_send_string(const char *msg) {
    while (*msg) {
        uart_send(*msg++);
    }
}

/**
 * @brief Проверяет, есть ли в приемном буфере непрочитанные байты.
 * @return Количество байт, доступных для чтения.
 */
uint8_t uart_available() {
    uint8_t count;
    // Безопасно вычисляем количество байт в буфере
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        count = (rx_buffer.head - rx_buffer.tail + RX_BUFFER_SIZE) % RX_BUFFER_SIZE;
    }
    return count;
}

/**
 * @brief Читает один байт из приемного буфера.
 * @return Прочитанный байт или -1, если буфер пуст.
 */
char uart_read() {
    // Если head и tail равны, буфер пуст
    if (rx_buffer.head == rx_buffer.tail) {
        return -1; // Возвращаем -1 как признак ошибки/пустого буфера
    }
    char b = rx_buffer.buffer[rx_buffer.tail]; // Берем байт из "хвоста"
    rx_buffer.tail = (rx_buffer.tail + 1) % RX_BUFFER_SIZE; // Сдвигаем "хвост"
    return b;
}

/**
 * @brief Читает строку из буфера, пока он не опустеет или не заполнится буфер назначения.
 * @param rx_data Указатель на массив, куда будут записаны данные.
 * @param max_len Максимальный размер этого массива.
 * @return true, если хотя бы один байт был прочитан, иначе false.
 */
bool uart_read_string(char *rx_data, uint8_t max_len) {
    if (!uart_available()) return false;
    uint8_t i = 0;
    while (uart_available() && i < (max_len - 1)) {
        rx_data[i++] = uart_read();
    }
    rx_data[i] = '\0'; // Завершаем строку нулевым символом
    return true;
}


// --- Обработчики прерываний (ISR - Interrupt Service Routine) ---

/**
 * @brief ISR для внешнего прерывания INT0.
 * Срабатывает, когда на RX-линии появляется спадающий фронт (начало старт-бита).
 */
ISR(INT0_vect) {
    // Немедленно отключаем это прерывание, чтобы избежать ложных срабатываний от "дребезга"
    // или от последующих битов в этом же байте.
    EIMSK &= ~(1 << INT0);

    // Переводим приемник в состояние приема битов данных
    rx_state = RX_DATA_BITS;
    rx_bit_index = 0; // Начинаем с 0-го бита
    rx_byte = 0;      // Очищаем байт для приема

    // Планируем первое срабатывание таймера для считывания бита.
    // Оно произойдет через 1.5 длительности бита от начала старт-бита.
    // Это позволяет нам считать значение бита ровно в его середине, что наиболее надежно.
    OCR1A = TCNT1 + (timer_ticks_per_bit * 3 / 2);
    TIMSK1 |= (1 << OCIE1A); // Включаем прерывание по совпадению A (для приемника)
}

/**
 * @brief ISR для таймера 1 по совпадению с OCR1A (канал A).
 * Используется для ПРИЕМА данных. Срабатывает для каждого бита.
 */
ISR(TIMER1_COMPA_vect) {
    // Сразу же планируем следующее прерывание ровно через один бит
    OCR1A += timer_ticks_per_bit;

    switch (rx_state) {
        case RX_DATA_BITS: // Состояние приема битов данных
            // Проверяем уровень на пине RX
            if (!(PIND & (1 << UART_RX_PIN))) {
                // Пин в низком уровне (логический 0).
                // Ничего не делаем, так как rx_byte уже инициализирован нулями.
            } else {
                // Пин в высоком уровне (логическая 1).
                // Устанавливаем соответствующий бит в принимаемом байте.
                rx_byte |= (1 << rx_bit_index);
            }
            rx_bit_index++; // Переходим к следующему биту

            // Если приняли все 8 битов данных
            if (rx_bit_index >= 8) {
                rx_state = RX_STOP_BIT; // Переходим в состояние ожидания стоп-бита
            }
            break;

        case RX_STOP_BIT: // Состояние ожидания стоп-бита
            // Проверяем, что на линии высокий уровень (корректный стоп-бит)
            if (PIND & (1 << UART_RX_PIN)) {
                // Стоп-бит корректен, сохраняем принятый байт в кольцевой буфер
                uint8_t next_head = (rx_buffer.head + 1) % RX_BUFFER_SIZE;
                // Проверяем, есть ли место в буфере
                if (next_head != rx_buffer.tail) {
                    rx_buffer.buffer[rx_buffer.head] = rx_byte;
                    rx_buffer.head = next_head;
                } 
                // Если места нет, байт будет потерян (frame error)
            }
            // Вне зависимости от корректности стоп-бита, завершаем прием
            rx_state = RX_IDLE;             // Возвращаемся в состояние ожидания
            TIMSK1 &= ~(1 << OCIE1A);       // Отключаем прерывание таймера A
            EIFR |= (1 << INTF0);           // Сбрасываем флаг прерывания INT0 на случай, если он установился
            EIMSK |= (1 << INT0);           // Снова включаем прерывание INT0, чтобы ловить следующий старт-бит
            break;

        default: // Если что-то пошло не так
             rx_state = RX_IDLE;            // Сбрасываем состояние
             TIMSK1 &= ~(1 << OCIE1A);      // Отключаем прерывание
             EIMSK |= (1 << INT0);          // Включаем ожидание старт-бита
             break;
    }
}

/**
 * @brief ISR для таймера 1 по совпадению с OCR1B (канал B).
 * Используется для ПЕРЕДАЧИ данных. Срабатывает для каждого бита.
 */
ISR(TIMER1_COMPB_vect) {
    // Сразу планируем следующее прерывание ровно через один бит
    OCR1B += timer_ticks_per_bit;
    
    switch (tx_state) {
        case TX_START_BIT:
            // Устанавливаем линию в низкий уровень для передачи старт-бита
            PORTD &= ~(1 << UART_TX_PIN);
            
            // Берем следующий байт для передачи из буфера
            tx_byte = tx_buffer.buffer[tx_buffer.tail];
            // Сдвигаем "хвост" буфера
            tx_buffer.tail = (tx_buffer.tail + 1) % TX_BUFFER_SIZE;

            tx_bit_index = 0; // Начинаем с 0-го бита
            tx_state = TX_DATA_BITS; // Переходим к передаче данных
            break;

        case TX_DATA_BITS:
            // Проверяем текущий бит в байте
            if (tx_byte & (1 << tx_bit_index)) {
                PORTD |= (1 << UART_TX_PIN);  // Если бит равен 1, устанавливаем высокий уровень
            } else {
                PORTD &= ~(1 << UART_TX_PIN); // Если бит равен 0, устанавливаем низкий уровень
            }
            tx_bit_index++; // Переходим к следующему биту
            
            // Если передали все 8 битов
            if (tx_bit_index >= 8) {
                tx_state = TX_STOP_BIT; // Переходим к передаче стоп-бита
            }
            break;

        case TX_STOP_BIT:
            // Устанавливаем высокий уровень для передачи стоп-бита
            PORTD |= (1 << UART_TX_PIN);
            // Байт полностью передан, переходим в состояние простоя
            tx_state = TX_IDLE;
            break;

        case TX_IDLE:
            // Это состояние наступает сразу после стоп-бита. Проверяем, есть ли еще данные для отправки.
            if (tx_buffer.head != tx_buffer.tail) {
                // Если буфер не пуст, сразу же начинаем передачу следующего байта
                tx_state = TX_START_BIT;
            } else {
                // Если буфер пуст, отключаем прерывание таймера B, чтобы не тратить ресурсы
                TIMSK1 &= ~(1 << OCIE1B);
            }
            break;
    }
}


// --- Пример использования (как в Arduino) ---

/**
 * @brief Функция начальной настройки. Выполняется один раз при старте.
 */
void setup() {
    uart_set_baudrate(9600);
    // Отправляем приветственное сообщение
    uart_send_string("Software UART Initialized.\nSend me something!\n");
}

/**
 * @brief Основной цикл программы. Выполняется бесконечно.
 */
void loop() {
    // Проверяем, есть ли принятые данные
    if (uart_available()) {
        char c = uart_read(); // Читаем один символ
        // Отправляем его обратно с префиксом "Echo: "
        uart_send('E');
        uart_send('c');
        uart_send('h');
        uart_send('o');
        uart_send(':');
        uart_send(' ');
        uart_send(c);
        uart_send('\n');
    }

    // Здесь можно выполнять другую полезную работу,
    // так как прием и передача данных происходят в фоновом режиме в прерываниях.
}

// int main(void) {
//     setup();
//     while(1) {
//         loop();
//     }
//     return 0;
// }