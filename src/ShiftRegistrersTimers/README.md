Данный проект реализует систему управления двумя семисегментными индикаторами через каскадное соединение сдвиговых регистров **74HC595**. Система функционирует как секундомер с диапазоном от **00** до **59**, обновляемый ровно раз в секунду.

Ключевой особенностью реализации является **полностью неблокирующая архитектура**. Все операции по отсчету времени, формированию сигнала и выводу данных на регистры выполняются внутри аппаратных прерываний таймера (**Timer1**). Основной цикл программы (`loop`) свободен от задач индикации и занят только обработкой пользовательского ввода через Serial-порт.

## Ключевые особенности решения

*   **Аппаратный тайминг:** Использование `Timer1` в режиме CTC (Clear Timer on Compare Match) для генерации прерываний с частотой ровно 1 Гц. Это обеспечивает высокую точность хода часов.
*   **Direct Port Manipulation:** Для управления пинами (Data, Clock, Latch) используется прямая запись в регистр `PORTB` микроконтроллера. Это значительно быстрее стандартных функций `digitalWrite` и `shiftOut`, а также демонстрирует понимание низкоуровневой работы MCU.
*   **Отсутствие `delay()`:** В коде не используются функции задержки, останавливающие процессор.
*   **Интерактивное управление:** Пользователь может задать текущее значение секунд через Serial Monitor в любой момент времени.
*   **Универсальность:** Поддержка индикаторов как с общим анодом, так и с общим катодом (настраивается в коде).

## Аппаратная конфигурация

### Компоненты
*   Arduino Uno (или совместимая плата на базе ATmega328P)
*   2x Сдвиговый регистр 74HC595 (8-бит)
*   2x Семисегментный индикатор (1 цифра)
*   16x Токоограничивающих резисторов (220 Ом - 330 Ом)

### Схема подключения (Pinout)

Управление осуществляется через порт B микроконтроллера (пины D8-D13 Arduino Uno):

| Функция | Пин Arduino | Пин PORTB | Пин 74HC595 | Описание |
| :--- | :--- | :--- | :--- | :--- |
| **DATA (DS)** | **D8** | PB0 | Pin 14 (Reg 1) | Вход данных первого регистра |
| **CLOCK (SHCP)** | **D9** | PB1 | Pin 11 (Both) | Тактовый сигнал (общий) |
| **LATCH (STCP)** | **D10** | PB2 | Pin 12 (Both) | Сигнал защелки (общий) |

**Каскадное соединение:**
1.  Выход переполнения **Q7' (Pin 9)** первого регистра подключается ко входу **DS (Pin 14)** второго регистра.
2.  Первый регистр управляет **десятками**.
3.  Второй регистр управляет **единицами**.

**Питание 74HC595:**
*   VCC (Pin 16) -> 5V
*   GND (Pin 8) -> GND
*   MR (Pin 10) -> 5V (Сброс не активен)
*   OE (Pin 13) -> GND (Выходы включены)

## Установка и Запуск

1.  **Настройка типа индикатора:**
    Откройте `src/main.cpp` и найдите строку:
    ```cpp
    #define IS_COMMON_ANODE true
    ```
    *   Установите `true`, если у вас индикатор с **общим анодом** (плюс общий).
    *   Установите `false`, если у вас индикатор с **общим катодом** (минус общий).

2.  **Загрузка прошивки:**
    Откройте проект в Arduino IDE или PlatformIO и загрузите код в плату.

3.  **Работа с устройством:**
    *   После загрузки на индикаторах начнется автоматический отсчет (00 -> 01 -> ...).
    *   Откройте **Монитор порта (Serial Monitor)** на скорости **9600 бод**.
    *   Введите двузначное число (например, `45`) и нажмите Enter.
    *   В момент следующего тика таймера значение счетчика изменится на введенное вами.

## Принцип работы кода

### 1. Таймер (Timer1)
Таймер настроен на частоту 1 Гц.
*   Предделитель: 1024
*   Режим: CTC
*   Значение регистра сравнения (`OCR1A`): 15624 (для 16 МГц кварца).

### 2. Прерывание (ISR)
Функция `ISR(TIMER1_COMPA_vect)` вызывается каждую секунду:
1.  **Обновление логики:** Проверяет флаг `hasNewData`. Если пришли данные из Serial — применяет их, иначе просто увеличивает счетчик.
2.  **Кодирование:** Разбивает число на десятки и единицы, преобразует их в байты для сегментов (по массиву `digitMap`).
3.  **Сдвиг данных:** Используя функцию `sendByteFast`, биты "проталкиваются" в регистры. Сначала отправляются биты для **единиц** (они пройдут сквозь первый регистр во второй), затем биты для **десятков** (останутся в первом).
4.  **Защелкивание:** Подается импульс на пин Latch, обновляя изображение на индикаторах мгновенно.

### 3. Главный цикл (Loop)
Цикл занимается исключительно чтением данных из `Serial`. При получении валидного числа (0-99), оно записывается в буферную переменную `nextValueBuffer`, и поднимается флаг для прерывания. Это гарантирует атомарность и безопасность данных.

*   [Ссылка на проект в Tinkercad](https://www.tinkercad.com/things/50J7SPnNFHs-shiftregistrerstimers)
